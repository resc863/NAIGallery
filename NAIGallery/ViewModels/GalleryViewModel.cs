using System.Collections.ObjectModel;
using System.Threading.Tasks;
using NAIGallery.Models;
using NAIGallery.Services;
using System.Linq;
using System;
using System.Collections.Generic;
using System.Threading;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;

namespace NAIGallery.ViewModels;

public enum GallerySortField { Name, Date }
public enum GallerySortDirection { Asc, Desc }

/// <summary>
/// ViewModel for the gallery page using CommunityToolkit.Mvvm to reduce boilerplate.
/// </summary>
public partial class GalleryViewModel : ObservableObject
{
    private readonly IImageIndexService _indexService;

    // Observable backing fields generated by source generator
    [ObservableProperty]
    private string _searchQuery = string.Empty;

    [ObservableProperty]
    private GallerySortField _sortField = GallerySortField.Name;

    [ObservableProperty]
    private GallerySortDirection _sortDirection = GallerySortDirection.Asc;

    [ObservableProperty]
    private bool _isIndexing;

    private CancellationTokenSource? _searchCts; // debounce token
    private List<ImageMetadata> _lastSearchResult = new();

    public ObservableCollection<ImageMetadata> Images { get; } = new();

    public event EventHandler? ImagesChanged;

    public GalleryViewModel(IImageIndexService service)
    {
        _indexService = service;
        // Initial population
        _ = ApplySearchAsync();
    }

    /// <summary>
    /// Command to index a folder and refresh results.
    /// </summary>
    public IAsyncRelayCommand<string> IndexFolderCommand => new AsyncRelayCommand<string>(IndexFolderAsync);

    /// <summary>
    /// Invoked when SearchQuery changes (source generator hook).
    /// </summary>
    partial void OnSearchQueryChanged(string value)
    {
        _ = ApplySearchAsync(throttle: true);
    }

    partial void OnSortFieldChanged(GallerySortField value) => ApplySortOnly();
    partial void OnSortDirectionChanged(GallerySortDirection value) => ApplySortOnly();

    /// <summary>
    /// Public method kept for code-behind compatibility; also used by command.
    /// </summary>
    public async Task IndexFolderAsync(string? folder)
    {
        if (string.IsNullOrWhiteSpace(folder)) return;
        if (IsIndexing) return;
        IsIndexing = true;
        try
        {
            await _indexService.IndexFolderAsync(folder);
            await ApplySearchAsync();
        }
        finally
        {
            IsIndexing = false;
        }
    }

    private IEnumerable<ImageMetadata> Sort(IEnumerable<ImageMetadata> src)
    {
        return _sortField switch
        {
            GallerySortField.Date => _sortDirection == GallerySortDirection.Asc ?
                src.OrderBy(m => m.LastWriteTimeTicks ?? 0L) :
                src.OrderByDescending(m => m.LastWriteTimeTicks ?? 0L),
            _ => _sortDirection == GallerySortDirection.Asc ?
                src.OrderBy(m => m.FilePath, StringComparer.OrdinalIgnoreCase) :
                src.OrderByDescending(m => m.FilePath, StringComparer.OrdinalIgnoreCase)
        };
    }

    private void ApplySortOnly()
    {
        if (_lastSearchResult.Count == 0) return;
        var sorted = Sort(_lastSearchResult).ToList();
        Images.Clear();
        foreach (var m in sorted) Images.Add(m);
        ImagesChanged?.Invoke(this, EventArgs.Empty);
    }

    private async Task ApplySearchAsync(bool throttle = false)
    {
        _searchCts?.Cancel();
        var cts = new CancellationTokenSource();
        _searchCts = cts;
        try
        {
            if (throttle)
                await Task.Delay(250, cts.Token);
            var results = _indexService.SearchByTag(_searchQuery).ToList();
            _lastSearchResult = results;
            if (cts.IsCancellationRequested) return;
            var sorted = Sort(results).ToList();
            Images.Clear();
            foreach (var m in sorted) Images.Add(m);
            ImagesChanged?.Invoke(this, EventArgs.Empty);
        }
        catch (TaskCanceledException) { }
    }
}
